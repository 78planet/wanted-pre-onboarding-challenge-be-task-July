# 동시에 같은 DB Table row 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하나요?

# 동시에 같은 `DB Table row` 를 접근하면 어떻게 될까요?

일관성과 충돌 문제가 발생할 수 있습니다. 다음과 같은 일이 생길 수 있습니다. 

1. 데이터 불일치: 동시에 접근하는 트랜잭션이 서로 다른 값을 읽거나 수정하면 데이터의 불일치가 발생할 수 있습니다. 예를 들어, 한 트랜잭션이 행의 값을 변경하고 다른 트랜잭션이 변경되기 전의 값을 읽으면 일관성이 깨질 수 있습니다.
2. 손상된 데이터: 동시에 접근하는 트랜잭션이 동일한 값을 수정하면 데이터가 손상될 수 있습니다. 두 개의 트랜잭션이 동시에 행을 업데이트하면 마지막으로 수행된 업데이트만 적용되고, 이전의 변경 사항은 손실될 수 있습니다.
3. 경합 상태 (Race Condition): 동시에 접근하는 트랜잭션이 동일한 값을 수정하려고 시도하면 경합 상태가 발생할 수 있습니다. 이는 두 트랜잭션이 서로의 작업을 덮어쓰거나 잘못된 결과를 생성하는 등의 문제를 일으킬 수 있습니다.

# 이런 충돌 상황을 어떻게 해결하나요?

## 데이터베이스 시스템은 이러한 충돌 상황을 방지하기 위해 트랜잭션 격리 수준(Isolation Level)을 제공

격리 수준은 동시에 수행되는 트랜잭션 간의 가시성과 일관성을 제어하는 규칙을 정의합니다. 다시말해 동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것입니다. 

1. Read Uncommitted **(커밋되지 않은 읽기)**
    - 가장 낮은 격리 수준으로, 트랜잭션에서 변경한 내용이 커밋되지 않았더라도 다른 트랜잭션에서 읽을 수 있습니다.
    - Dirty Read(더티 리드), Non-repeatable Read(비 반복 가능한 읽기), Phantom Read(유령 읽기) 등의 문제가 발생할 수 있습니다.
    - 데이터 일관성과 격리성이 보장되지 않습니다.
    - 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장합니다.
2. Read Committed (**커밋된 읽기)**
    - 트랜잭션이 커밋된 데이터만 읽을 수 있습니다. 커밋되지 않은 데이터에 대해서는 다른 트랜잭션에서 읽을 수 없습니다.
    - Dirty Read는 방지하지만, Non-repeatable Read와 Phantom Read는 발생할 수 있습니다.
    - 대부분의 데이터베이스 시스템에서 기본적으로 사용되는 격리 수준입니다.
3. Repeatable Read (**반복 가능한 읽기)**
    - 트랜잭션이 시작될 때 읽은 데이터를 트랜잭션이 종료될 때까지 일관되게 유지합니다. 따라서 같은 쿼리를 여러 번 실행해도 동일한 결과를 보장합니다.
    - 자신의 트랜잭션이 생성되기 이전의 트랜잭션에서 COMMIT 이 된 데이터만 읽습니다.
    - Dirty Read와 Non-repeatable Read는 방지하지만, Phantom Read는 발생할 수 있습니다.
    - 대부분의 상황에서 데이터 일관성을 유지하는 데에 적합한 격리 수준입니다.
4. Serializable
    - 가장 높은 격리 수준으로, 모든 트랜잭션이 순차적으로 실행되는 것처럼 동작합니다. 이를 통해 가장 엄격한 일관성과 격리성을 제공합니다.
    - 데이터를 접근할 때, 항상 Lock을 걸고 데이터를 조회합니다.
    - Dirty Read, Non-repeatable Read, Phantom Read를 모두 방지합니다.
    - 동시성 수준이 가장 낮아 성능에 영향을 줄 수 있으며, 동시 처리량이 감소할 수 있습니다. 따라서 대규모 동시 접근이 필요한 시스템에서는 사용을 최소화하는 것이 좋습니다.

트랙잭션 문제들

- Dirty Read
    - 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
    - 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랙잭션에 의한 변경사항을 보게 되는 경우
    - Read Uncommitted
- Non-Repeatable Read
    - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상
    - Read Uncommitted, Read Committed
- Phantom Read
    - 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
    - 트랜잭션 도중 새로운 레코드를 삽입을 허용하기 때문에 나타나는 현상
    - Read Uncommitted, Read Committed, Repeatable Read

## 데이터베이스 시스템은 락(Lock) 메커니즘을 사용하여 동시 접근을 제어할 수 있음

락은 특정 행이나 테이블에 대한 동시 업데이트를 제한하고, 한 번에 하나의 트랜잭션만이 접근할 수 있도록 합니다. 이를 통해 충돌을 방지하고 데이터 일관성을 유지할 수 있습니다.

락 메커니즘은 일반적으로 다음과 같은 유형의 락을 사용합니다:

1. 공유 락 (Shared Lock 또는 Read Lock):
공유 락은 여러 트랜잭션이 동일한 데이터를 동시에 읽을 수 있도록 허용합니다. 동시 읽기 작업은 데이터의 일관성에 영향을 주지 않기 때문에 공유 락을 사용하여 여러 트랜잭션이 동시에 읽을 수 있도록 허용합니다. 하지만 공유 락을 획득한 트랜잭션은 다른 트랜잭션이 해당 데이터를 수정하지 못하도록 제한합니다.
2. 배타 락 (Exclusive Lock 또는 Write Lock):
배타 락은 특정 데이터에 대한 동시 업데이트를 제한합니다. 배타 락을 획득한 트랜잭션은 해당 데이터를 수정하거나 삭제할 수 있지만, 다른 트랜잭션이 동시에 동일한 데이터를 수정하지 못하도록 합니다. 배타 락은 데이터의 일관성을 보장하고, 충돌이 발생하지 않도록 합니다.

### ****Locking을 활용한 동시성 제어 기법****

- **낙관적 락 (optimistic lock)**
    - 충돌이 발생할 가능성이 낮은 경우 사용되는 동시성 제어 기법이다.
    - 충돌이 발생하면 재시도 또는 병합을 통해 충돌을 해결한다.
    - 실제로 lock을 사용하지 않고 **version**을 이용함으로서 정합성을 맞추는 방법이다. 데이터를 읽을 때 lock을 사용하지 않고, 업데이트 시 **내가 읽은 version이 맞는지 충돌 여부를 확인**하여 처리한다.
    - **즉, 자원에 lock을 직접 걸어서 선점하지 않고, 동시성 문제가 실제로 발생하면 그때가서 처리하는 방식이다.**
    - 트랜젝션을 필요로 하지 않고, 별도의 lock을 사용하지 않으므로 성능적으로 좋다.
    - 동시성 문제가 빈번하게 일어나면 계속 rollback 처리를 해주어야 하며, 업데이트가 실패했을 때 재시도 로직도 개발자가 직접 작성해야 한다.
- **비관적 락 (pessimistic lock)**
    - 충돌이 발생할 가능성이 높은 경우 사용되는 동시성 제어 기법이다.
    - 데이터를 읽거나 수정하기 전에 lock을 획득하여 다른 사용자의 액세스를 차단하고, lock을 가진 스레드만 접근하도록 제어한다.
    - 데이터에 대한 배타적인 액세스 권한을 보장하여 충돌을 방지한다.
    - 실제로 데이터에 lock을 걸어서 정합성을 맞추는 방법으로, 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 lock을 걸어버리는 방법이다.
    - **즉, 트랜젝션이 시작할 때 s-lock이나 x-lock을 실제로 걸고 시작한다.**
    - 동시성 문제가 빈번하게 일어난다면 rollback의 횟수를 줄일 수 있기 때문에 성능적으로 좋다.
    - 모든 트랜젝션에 lock을 사용하기 때문에, lock이 필요하지 않은 상황이더라도 무조건 lock을 걸어서 성능상 문제가 될 수 있다. 특히 read 작업이 많이 일어나는 경우 단점이 될 수 있다. 또한, 선착순 이벤트같이 많은 트래픽이 몰리는 상황이나 여러 테이블에 lock을 걸면서 서로 자원이 필요한 경우, 데드락이 발생할 수 있고 이는 비관적 락으로 해결할 수 없는 부분이다.
- **분산락 (distributed lock)**
    - 여러 컴퓨터 또는 프로세스 간에 공유된 자원에 대한 동시 액세스를 제어하기 위해 사용된다.
    - **분산 시스템에서 동시성 문제를 해결**하기 위해 사용되며, **분산된 서버 또는 클러스터 간**의 상호작용이 필요하다.
    - 주로 **데이터베이스나 메시지 큐 등의 분산 시스템**에서 사용된다.
    - 대표적인 분산락 기법으로는 ZooKeeper, Redis 등이 있다.
    - **Redis**는 RedLock이라는 알고리즘을 제안하며 3가지 특성을 보장해야한다고 한다.
        - 오직 한 순간에 하나의 작업자만이 락(lock) 을 걸 수 있다.
        - 락 이후, 어떠한 문제로 인해 락을 풀지 못하고, 종료된 경우라도 다른 작업자가 락을 획득할 수 있어야합니다.
        - Redis 노드가 작동하는한, 모든 작업자는 락을 걸고 해체할 수 있어야합니다.
    - 분산 락을 구현하기 위해 lock에 대한 정보를 Redis에 저장하고 있어야한다. 그리고 분산환경에서 여러대의 서버들은 공통된 Redis를 바라보며, 자신이 공유 자원에 접근할 수 있는지 확인한다.
- **스핀락 (spin lock)**
    - **자원에 대한 접근이 필요할 때 무한루프를 돌면서 반복적으로 확인**하며, 다른 스레드가 lock을 해제할 때까지 대기한다.
    - 경쟁 상태 (2개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓰는 상황)가 짧고 자원 점유 시간이 길지 않은 경우에 효과적이다.
    - 주로 멀티코어 시스템에서 사용되며, 락 획득을 위해 CPU를 계속 사용하므로 서버에 많은 부하를 주어 주의해야 한다.

### MVCC (Multi-Version Concurrency Control)

### MVCC 등장 배경: Locking의 한계

Lock 메커니즘은 기본적으로 동시 작업 수를 제한하는 방식이다.

하나의 쓰레드가 락을 보유하는 동안 다른 쓰레드는 락을 기다리는 상태에 들어간다.

이렇게 하면 당연히 속도가 느려지고 처리량이 낮아질 수밖에 없다.

이러한 방식을 개선시켜 등장한 것이 MVCC다.

MVCC는 DBMS가 기본적으로 제공하는 기능이다.  MVCC는 Undo-Log라는 영역을 사용해서 격리 수준이 Read Committed만 되어도 항상 Non-Repeatable Read 현상을 막아준다.

그렇기에 MVCC가 작동해서 Non-Repeatable Read를 막아주고 있는데 동시성 제어를 위해 락을 한번 더 걸어주면 MVCC의 이점을 무효화하는 행위를 하는 것이다.

- **특징**
    - MVCC의 접근 방식은 잠금을 필요로 하지 않기 때문에 일반적인 RDBMS보다 매우 빠르게 작동한다.
    - 데이터를 읽기 시작할 때, 다른 사람이 그 데이터를 삭제하거나 수정하더라도 영향을 받지 않고 데이터를 사용할 수 있다.
    - 대신 사용하지 않는 데이터가 계속 쌓이게 되므로 데이터를 정리하는 시스템이 필요하다.
    - MVCC 모델은 하나의 데이터에 대한 여러 버전의 데이터를 허용하기 때문에 데이터 버전이 충돌될 수 있으므로 애플리케이션 영역에서 이러한 문제를 해결해야 한다.
    - UNDO 블록 I/O, CR Copy 생성, CR 블록 캐싱 같은 부가적인 작업의 오버헤드 발생한다.

일반적으로 MVCC는 다음과 같은 개념과 기능을 활용합니다

1. 버전 스냅샷 (Version Snapshot):
MVCC에서는 트랜잭션이 시작될 때의 데이터 상태를 스냅샷으로 생성합니다. 이 스냅샷은 해당 트랜잭션에 대한 일관된 데이터 뷰를 제공하는 데 사용됩니다. 이후에 다른 트랜잭션이 데이터를 수정해도 해당 트랜잭션의 스냅샷은 변경되지 않습니다.
2. Read Consistency (일관된 읽기):
MVCC는 트랜잭션이 읽는 동안 다른 트랜잭션이 데이터를 수정하더라도 일관성 있는 읽기를 보장합니다. 트랜잭션은 자신의 스냅샷을 기준으로 데이터를 읽으며, 다른 트랜잭션에서 수정 중인 데이터는 영향을 받지 않습니다.
3. Versioning (버전 관리):
MVCC는 데이터의 버전 관리를 수행합니다. 데이터베이스 시스템은 각 행의 변경 이력을 관리하고, 트랜잭션이 발생할 때마다 새로운 버전을 생성합니다. 이렇게 생성된 버전은 스냅샷과 함께 트랜잭션의 일관된 데이터 뷰를 제공하는 데 사용됩니다.
4. Concurrency Control (동시성 제어):
MVCC는 다중 버전을 사용하여 동시성 제어를 수행합니다. 각 트랜잭션은 자신의 스냅샷과 버전 정보를 기반으로 동시에 수행될 수 있습니다. 데이터에 대한 동시 업데이트 작업은 서로 다른 버전을 사용하므로 충돌이 발생하지 않고, 동시성 문제를 효과적으로 제어할 수 있습니다.

MVCC는 다중 버전을 사용함으로써 데이터 일관성과 동시성을 동시에 보장하며, 락(Lock) 메커니즘에 비해 높은 동시성 처리량을 제공할 수 있습니다. 그러나 MVCC는 추가적인 스토리지 공간을 필요로 하며, 데이터의 버전 관리와 정리가 필요할 수 있습니다. 따라서 데이터베이스 시스템에서 MVCC를 사용할 때는 이러한 고려사항을 고려하여 성능과 스토리지 요구사항을 평가해야 합니다.
